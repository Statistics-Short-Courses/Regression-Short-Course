---
format: live-html
engine: knitr
---
{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

# Simple Linear Regression: fitting a model to data

in the previous section, you were given a linear model - we knew the
values of $\beta_0$, $\beta_1$ and even $\sigma$. However, in most
contexts we don't know the true relationship between $X$ and $Y$ in
advance. Instead, we are given *data* and try to *infer* the values of
$\beta$, $\sigma$ based on this.

## Estimating parameters

### Residuals

### Estimating $\beta$

Which line fits the data best (how low can the RMSE go)?

```{ojs}
//| echo: false
//| export: linearData
x = Array.from({length: 50}, d3.randomNormal(180, 50))
noise = Array.from({length: 50}, d3.randomNormal(0, 15))
y = x.map((xi, i) => 0.5 * xi - 10 + noise[i])

linearData = x.map((xi, i) => ({ x: xi, y: y[i] }))
```

```{ojs}
//| panel: sidebar
//| echo: false
viewof b0adj = Inputs.range([-50, 50], {step: 1, label: html`${tex`\beta_0`}: Intercept (adjustment)`})
viewof b1 = Inputs.range([-2, 2], {step: 0.01, label:  html`${tex`\beta_1`}: Slope`})

b0 = (90 - b1 * 180) + b0adj

residualData = linearData.map(d => {
  const yhat = b1 * d.x + b0;
  const res  = d.y - yhat;
  return {
    ...d,
    yhat,
    residual: res,
    sign: res >= 0 ? "positive" : "negative",
    absRes: Math.abs(res)
  };
})

RMSR = Math.sqrt(d3.sum(residualData, d => d.residual ** 2) / residualData.length)

tex.block`y = ${b1}x + ${b0}`

tex.block`\sqrt{\frac{1}{n}\sum_{i}r_i^{2}} = ${RMSR.toFixed(2)}`
```

```{ojs}
//| panel: fill
//| echo: false

xRange = d3.extent(residualData,d => d.x)
lineData = xRange.map(x => ({x, y: b1 * x + b0}))

Plot.plot({
  marks: [
    Plot.ruleX(residualData, {x: "x",
      y1: "y",
      y2: "yhat",
      stroke: "sign", 
      strokeOpacity: 0.75,
      strokeWidth: d => 1 + d.absRes / 12,
       title: d => `x=${d.x.toFixed(1)}
y=${d.y.toFixed(1)}
ŷ=${d.yhat.toFixed(1)}
res=${d.residual.toFixed(1)}
res²=${(d.residual**2).toFixed(1)}`
    }),

    Plot.line(lineData, { x: "x", y: "y" }),

    Plot.dot(linearData, { x: "x", y: "y", r: 3 })
  ],
  x: { domain: xRange },
  y: { domain: [0, 180], label: "y" },
})
```


### Fitting a model using least squares - lm()

```{webr}
#| input:
#|   - linearData

lm(y~x,linearData)
```
### Estimating $\sigma$

## Checking assumptions

### Independence of observations
### Linear relationships
### Constant Variance
### Normality of error

## Inference for Simple Linear Regression
### Overall fit
### Parameter estimates

## Interpreting \`summary()\` output
