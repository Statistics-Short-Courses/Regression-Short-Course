---
format: 
  live-html:
    toc: true

execute:
  echo: true
  warning: false
  message: false

editor: 
  markdown: 
    wrap: 72
    
embed-resources: true

custom-numbered-blocks:
  classes:
    Assumption:
      colors: [FF9580, FFBF80]
      collapse: false
    Example: 
      collapse: false
    ToDo: default
    Technical-Point: default
    
filters:
- custom-numbered-blocks
---

{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

```{r}
#| include: false
library(ggplot2)
```


# An introduction to linear statistical models

-   A primary goal of statistical modelling is to characterise the relationship between variables, for now lets call them $X$ and $Y$.
-   In this context, we designate one variable, $Y$ as the *outcome* or *dependent variable*, and attempt to construct a *model* describing how it depends on the other variable(s), $X$, which we call *predictors* or *independent variables*. 
-   We can express the idea that $Y$ depends on $X$ mathematically as
$$
Y=f(X)
$$
-   That is, $Y$ is some function of $X$ (we have not yet specified what kind of function). Given values of $X$, we can use this function to *predict* or *explain* corresponding values of $Y$.

- This is similar to *deterministic models* you may know from physics - for example 
 $$E=MC^2$$,
 where $E$ (the outcome), depends on $M$ (a predictor) through the function $f(M)=MC^2$). 
 
- In statistical modelling we take another step and assume that $Y$ is not a purely determinsitic function of $X$, but that it varies somewhat randomly around such a relationship. We capture this by introducing a *random error term *, $\varepsilon$:
$$
Y=f(X)+\varepsilon
$$ {#eq-statistical-model}

Here $\varepsilon$ represents the random variation in $Y$ that is not explained by $X$. 

- This means that $Y$ is not perfectly determined by $X$: even if we know the values of X, the outcome Y can still vary due to random noise. 

::: Assumption 
$Y$ depends only on a deterministic function of $X$ and a random noise component
:::

## A simple linear model

### Linear prediction

-   We now choose $f(X)$ to be a *linear function*:

$$
f(X)= \beta_0 + \beta_1\cdot X
$$

-   Putting aside the random error term for the moment, we can think of the *expected value* of $Y$, denoted $E[Y]$, as being given by this linear relationship:

$$
E[Y]= \beta_0 + \beta_1\cdot X
$$ {#eq-deterministic-linear-model}

- In other words, we are representing the expected value of $Y$ as a *straight line* with y-intercept $\beta_0$ and slope $\beta_1$:

```{ojs}
//| panel: sidebar
//| echo: false
viewof b1 = Inputs.range([-2, 2], {step: 0.1, label: "Slope (β₁)"})
viewof b0 = Inputs.range([-10, 10], {step: 1, label: "Intercept (β₀)"})
tex.block`E[Y] = ${b1}X + ${b0}`
```

```{ojs}
//| panel: fill
//| echo: false
//| fig-cap: "Plot of the linear function E[Y] = β₀+ β₁X"
xRange = [-10,10]
lineData = xRange.map(x => ({x, y: (b1 * x) + b0}))
Plot.plot({
  x:{domain: [-10,10], label: "X", grid: true},
  y:{domain: [-10,10], label: "Y", grid: true},
  marks: [
    Plot.line(lineData, { x: "x", y: "y" })]
})

```

-   Here, $\beta_0$ represents the value of $Y$ when $X=0$, and
    $\beta_1$ represents the change in Y for a one-unit increase in X.
    
::: Assumption 
Y and X have a linear relationship
:::

::: Example
#### Salary growth over time

You've been offered a job at ~company A~, and want to predict your salary at this company after working there for 10 years. 
We know that, on average, the *starting salary* at this company is \$50,000, and salaries increase by \$5000 per year of employment. 

Using this information, we can construct a simple linear predictor of salary from employment time. Given an employment time of $X=x$ years, we can represent a employee's expected salary ($E[Y]$) as

$$
E[Y]= \$50,000 + \$5,000\cdot x.
$$

After 10 years of working at this company (i.e. $X=10$), we would expect a salary of 
$$E[Y]=\$50,000 + \$5,000\times10= \$100,000$$

:::

::: {.webex-check .webex-box}
#### Your turn 

A second company also has a job available. The *starting salary* is higher here - \$70,000 on average - but payrises are smaller. You are told that, on average, employees working for the company for 5 years earn \$20,000 more per year than when they started. 

You want to use a simple linear prediction to calculate your expected salary ($E[Y]$) after $X$ years of employment. 

$$
E[Y] = \beta_0 + \beta_1 X
$$

1. What are the coefficients $\beta_0$ and $beta_1$ in this case?

```{r}
#| echo: false
#| results: 'asis'
library(webexercises)
beta0_quiz <- fitb(answer= 70000, num=TRUE)
beta1_quiz <- fitb(answer=4000, num=TRUE)

```

$\beta_0 =$`{r} I(beta0_quiz)`
$\beta_1 =$`{r} I(beta1_quiz)`

Using R, calculate the expected salary after working for this company for 10 years

```{webr}
#| exercise: example_2

```

```{webr}
#| exercise: example_2
#| check: true
if (identical(.result, 70000+(4000*10))) {
  list(correct = TRUE, message = "Nice work!")
} else {
  list(correct = FALSE, message = "That's incorrect, sorry.")
}
```
2. Complete the r function that predicts $Y$ from an input $X$ for this linear model 
(alternatively - give function e.g. 'this function predicts salary at company 2 with an input X years work')
```{webr}
#| exercise: r_function
#| envir: linear_predictor_function
linear_prediction <- function(X){__ + (__*__)}
```

```{webr}
#| exercise: example_2
#| check: true
if (identical(.result, 50000+(5000*10))) {
  list(correct = TRUE, message = "Nice work!")
} else {
  list(correct = FALSE, message = "That's incorrect, sorry.")
}
```
Use this function to predict $Y$ for the following values of $X$
```{webr}
#| edit: false
X <- c(9,4,5,2,6)
```

```{webr}
#| exercise: r_function_call
#| envir: linear_predictor_function


```

```{webr}
#| exercise: r_function_call
#| check: true
if (identical(.result, 50000+(5000*X))) {
  list(correct = TRUE, message = "Nice work!")
} else {
  list(correct = FALSE, message = "That's incorrect, sorry.")
}
```

:::: ToDo
add plot comparing two (companies) linear salary growth? 
::::

:::


### Random Errors

-   In practice, data rarely fall perfectly on a straight line. Even if the underlying relationship between $X$ and $Y$ is approximately linear, individual observations tend to vary around that line.

-   As mentioned in Section 1.x,  to account for this variation we add an *error term*, $\varepsilon$, to our model 

$$
Y=\beta_0 + \beta_1X + \varepsilon
$$

#### Mean Zero
- The error term represents the *difference between the actual value of $Y$ and the value predicted by the linear predictor, $E[Y]$.
- On average, we expect these error terms to balance out:

::: Assumption 
The mean of the error term is zero:

$$
E[\varepsilon]=\mu=0
$$

i.e. The linear predictor gives the correct value of $Y$ on average
:::


#### Constant variance

- While correct on average, we expect there to be some *spread* of data around the line (this is why we have the error term). The amount of spread is measured by the *variance* of the errors.
- We assume that this variance is *constant* - like $mu=0$, it is the same for all values of $X$ however we dont specify which particular value it takes:

::: Assumption 
The variance of the error term is constant for all values of X:
$$Var(\varepsilon)=\sigma^2$$
:::

#### Normal distribution 

While the assumptions of mean 0 and constant variance describe the center and spread of the errors, they don’t fully specify the shape of their distribution. To model this more completely, we often assume that the errors follow a Normal distribution.

::: Assumption
The error is normally distributed (with mean $\mu=0$ and variance $\sigma^2$ .
$$\varepsilon \sim \mathcal{N}(0, \sigma^2)$$
:::

```{ojs}
//| echo: false
//| panel: sidebar
viewof mu = Inputs.range([-5, 5], {
  value: 0,
  step: 0.1,
  label: `Mean (μ):`
})

viewof sigma = Inputs.range([0.2, 5], {
  value: 1,
  step: 0.1,
  label: 'Standard deviation (σ):'
})

SQRT2PI=Math.sqrt(2 * Math.PI)

normalDensity = (x, mean, sd) =>
  (1 / (sd * SQRT2PI)) * Math.exp(-0.5 * ((x - mean) / sd) ** 2);
  
densityGrid_1 = d3.range((-4 * sigma)+mu, mu+(4 * sigma), sigma / 50).map(x => ({
  x,
  density: normalDensity(x,mu,sigma)
}));

tex.block`\varepsilon \sim \text{Normal}(${mu}, ${sigma}^2)`
```


```{ojs}
//| echo: false
//| panel: fill
//| fig-cap: "Normal distribution with adjustable mean and standard deviation."

Plot.plot({
  height: 280,
  marginLeft: 48,
  marginBottom: 40,
  y: { label: "Density" },
  x: {domain: [-10,10], label: "ε" },
  marks: [
    Plot.areaY(densityGrid_1, {
      x: "x",
      y: "density",
      fillOpacity: 0.2,
      stroke: "#2a5599",
      fill: "#2a5599"
    })
  ]
})
```

::: Technical-Point
The Central Limit Theorem is a fundamental result of probability theory that provides some extra motivation for this assumption. According to this theorem, sums or averages of many small, independent random effects tend to follow a Normal distribution. Thus, assuming normally distributed errors is both a practical simplification and a reasonable approximation in many situations.
:::

### The Simple Linear Model

Putting these pieces together we are left with:

$$
Y=\beta_0+\beta_1X+\varepsilon, \quad{\varepsilon \sim N(0,\sigma^2)}
$$

This 'simple linear model' is the starting place for conducting linear regression - in which whe 'fit' (i.e. estimate the values of $\beta_0$, $\beta_1$, and $\sigma^2$) from data. 

```{ojs}
//| panel: sidebar
//| echo: false

viewof b1_2 = Inputs.range([-2, 2], {step: 0.1, label: "Slope (β₁)"})
viewof b0_2 = Inputs.range([-10, 10], {step: 1, label: "Intercept (β₀)"})
viewof sigma_2 = Inputs.range([0.2, 5], {step: 0.1, value: 1, label: "Std. deviation (σ)"})
viewof showHeatmapLayer = Inputs.toggle({label: "Show heatmap", value: true})
viewof showCrossSectionLayer = Inputs.toggle({label: "Show cross-section curves", value: true})
viewof crossSectionCount = Inputs.range([2, 12], {
  step: 1,
  value: 7,
  label: "Number of cross-sections"
})

tex.block`Y = ${b0_2} + ${b1_2}X + \varepsilon, \quad \varepsilon \sim \text{Normal}(0, ${sigma_2}^2)`
```

```{ojs}
//| panel: fill
//| echo: false
//| width: 700
//| fig-cap: "Layers illustrating the simple linear model: toggle the heatmap of normal errors and the cross-sectional curves."

const xValues = d3.range(-10, 10.001, 0.3);
const xSectionDomain = [-8, 8];
const ySectionValues = d3.range(-10, 10.001, 0.1);

const computeHeatmapGrid = () =>
  xValues.flatMap(x => {
    const mu = b0_2 + b1_2 * x;
    return xValues.map(y => ({
      x,
      y,
      density: normalDensity(y, mu, sigma_2)
    }));
  });

const computeCrossSectionGeometry = () => {
  const widthScale = Math.min(1.8, sigma_2 * 0.9);
  const count = Math.max(2, Math.round(crossSectionCount));
  const step =
    count === 1
      ? 0
      : (xSectionDomain[1] - xSectionDomain[0]) / (count - 1);
  const xSampleValues = Array.from({length: count}, (_, i) =>
    xSectionDomain[0] + i * step
  );

  const curves = xSampleValues.flatMap(xVal => {
    const mu = b0_2 + b1_2 * xVal;
    const peakDensity = normalDensity(mu, mu, sigma_2);

    return ySectionValues.map((y, index) => {
      const density = normalDensity(y, mu, sigma_2);
      const width = (density / peakDensity) * widthScale;
      return {x: xVal + width, y, group: xVal, order: index};
    });
  });

  const trend = xValues.map(x => ({
    x,
    y: b0_2 + b1_2 * x
  }));

  return {curves, trend};
};

const heatmapGrid = showHeatmapLayer ? computeHeatmapGrid() : null;
const crossSections = showCrossSectionLayer ? computeCrossSectionGeometry() : null;

const plotOptions = {
  x: {domain: [-10, 10], label: "X", grid: true},
  y: {domain: [-10, 10], label: "Y", grid: true},
  marks: [
    ...(showHeatmapLayer
      ? [Plot.raster(heatmapGrid, {x: "x", y: "y", fill: "density", interpolate: "nearest"})]
      : []),
    ...(showCrossSectionLayer
      ? [
          Plot.line(crossSections.curves, {
            x: "x",
            y: "y",
            z: "group",
            stroke: "#2a5599",
            strokeWidth: 1.5,
            curve: "basis"
          }),
          Plot.line(crossSections.trend, {x: "x", y: "y", stroke: "black", strokeWidth: 2})
        ]
      : [])
  ]
};

if (showHeatmapLayer) {
  plotOptions.color = {
    label: "Density",
    type: "sequential",
    scheme: "Blues"
  };
}

Plot.plot(plotOptions);

```
::: Example
-   Same model as above - given standard deviation
-   Example Y values
    -   Illustrate error with normal overay
-   Excersises:
    -   which variance is larger?
    -   (hard) probability of finding E\[Y\]+2sd observation
:::
